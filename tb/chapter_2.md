#CHAPTER 2 NOTES - CS11
##2.1

**variables**
- variables are implemented as memory locations; compiler assigns a memory location to each variable name 
- should use meaningful names for variables (name for a variable is called an <i>identifier</i>
- identifier must start with a letter or underscore symbol, and all other characters must be letters, digits, or an undercore 
- identifiers should be descriptive
- C++ is **case sensitive** ; and identifiers are usually all lowercase
- **keywords** or **reserved words** have a predefined meaning in C++

**variable declarations**
- variables must be declared; kind of data held in a variable is called its **type**
- variables should be declared just before they are used or right after the signature of a function

	//variable declaration
	Type_Name Variable_Name_1,

**assignment statements**
- most direct way to change the value of a variable
- always consists of a a variable on the left side and an expression on the right side

	//assignment statements
	variable = expression;	
-make sure to initialize variables before using them or they are given a garbage value based on what was stored on that memory location previously

	//initializing variables in declarations
	type_name variable_name = expression;
	//or
	type_name variable_name (expression);
	
##2.2

**input and output**
- several ways that a C++ program can perform input/output
- **input stream** is the stream of input being fed into the computer for it to use
- stream can come from a keyboard, a file, an html page, a **supreme web scraper**, etc...
- an **output stream** is a stream generated by the program (assume it goes to a terminal screen for now)

**output using cout**
- values of variables as well as strings of text can be output to the screen using **cout** 
- can be a combination of variables and strings

	//example
	cout << number_of_bars << " candy bars\n";
	//is equivalent to
	cout << number_of_bars;
	cout << " candy bars\n";
	
	//can also include artihmetic expressions in a cout statement:
	cout << "The total cost is $" << (price + tax);
	//many compilers require you to use parentheses around arithmetic
	expressions
	
-==<<== is called the insertion operator
- can place a long cout statement on two or more lines for better style
- don't break a quoted string on two lines
- ==\n== is the newline

**include directives and namespace**

	//all programs so far start with
	#include <iostream> //the include directive (includes iostream library so cin and cout are available)
	using namespace std; //a namespace is a collection of names; this is a using directive 
	
-the using directive in the code above says that the program is using the std namespace so names that are being used are defined in the std namespace
- C++ uses namespaces bc of all the stuff that has to be named and sometimes two or more things have the same name; to eliminate ambiguities, items are divided into collections so no two vars have the same name
- a namespace is not just a collection of names, but a body of code that specifies the meaning of some names such as definitions and declarations

**escape sequences**
- backslash tells compiler that the character following the backslash has a different meaning -- they are **escape sequences**

	//some escape sequences
	
	//new line \n
	//alert \a
	//backslash \\
	//double quote \"
	
-C++11 supports **raw string literals**, which is convenient with strings with lots of escape characters
- use an 'R' followed by the string in parens

	cout << R"(C:\files\)";
	
	//programming tip
	//if you want a certain number of decimals being outputted in a program, use these three lines:
	cout.setf(ios::fixed);
	cout.setf(ios::showpoint);
	cout.precision(2);
	//these three statements will outputdoubles in ordinary notation with two digits after the decimal point
	
**input using cin**
- arrows point in the opposite direction
- can have multiple variables in a single cin statement:

	cout<< "enter the number of dogs in a litter\n";
	cout<< "and the avg weight of each dog.\n";
	cout<< "then press return.\n";
	cin>> number_of_dogs >> avg_weight;
	
-when a program reaches a ==cin== statement, it waits for input to be entered, separated by one or more spaces or a line break.
- the program reads the input once the return key is pressed

**designing input and output**
- user unhappy with bad I/O
- give the user prompts and echo the input

##2.3 

**the types int and double**
- numbers of type int are stored as exact values; those of type double are stored as approximated values 
- doubles are usually tored with 14 or more digits of accuracy
- doubles can be whole nums or decimals, but ints can only be whole numbers
- floats are single-precision numbers that use half as much storage as floats and are less precise; long doubles also exist for fractional numbers
- doubles can be written as decimals or scientific/floating point notation

	//ex:
	0.000000589 //or 5.89 * 10^-6 //is equal to 5.89e-6
	//in C++
	
-C++ allows ints as large as 2,147,483,647 and doubles as large as 10^308^

**other number types**

	//floating-point types are for decimal/fraction nums like double
	
	float num; //4 bytes, 10^-38 to 1^38, 7 digits precise
		
	double num; //8 bytes, 10^-308 to 10^308, 15 digits precise
	
	long double num; //10 bytes, 10^-4932 to 10^4932, 19 digits precise
	
	//integer types are for whole number types
	
	short num; //2 bytes, -32,768 to 32,767
	int num; //4 bytes, -2,147,483,648 to 2,147,483,647
	
	//the two types below are the same
	
	long bignum; //4 bytes, -2,147,483,648 to 2,147,483,647
	long int bignum;
	
-when a computer performs the conversion to e notation for a floating-point, the decimal moves (floats) to a new position

==**C++ 11 types**==
- difference in size of integer data types from 32-bit to 64-bit machines, so new integer types added to C++11 specifiying size and signage
- types accessible using 'cstdint' library
- use C++11 types if wanting to specify an exact size
- C++11 also includes type ==auto== that deduces the type of variable based on the expression on the right

	//fixed width integer types
	int8_t	 //1 byte	 - 128 to 127
	uint8_t	 //1 byte	 0 to 255
	int16_t	 //2 bytes	 - 32,768 to 32,767
	uint16_t	 //2 bytes	 0 to 65,535
	int32_t	 //4 bytes	 - 2,147,483,648 to 2,147,483,647
	uint32_t	 //4 bytes	 0 to 4,294,967,295
	int64_t	//8 bytes	 - 9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
	 uint64_t	 //8 bytes	 0 to 18,446,744,073,709,551,615
	 long long	// At least 8 bytes
	
-also includes ==decltype==(expr) which works the other way in that a var of type ==decltype== has the same type of the expression being evaluated by it

==**char**==
- single symboles like a letter, digit, or punctuation mark (short for character)

	//declaration
	char 'c';

-vars of type char are different from strings; values of type char are enclosed in single quotes, while strings are enclosed in double quotes

==**bool**==
- added by ISO/ANSI (International Standards Organization/American Standards Organization) in 1998
- named after George Boole, an English mathematician
- "true" or "false"

==**string class**==
- C++ lacks a native data type to manipulate strings
- to use the string class, include the **string** library

	//include string library
	#include <string>
	using namespace std;
	
	//declare strings like any other native types
	string day = "monday";
	
-can use **cin** and **cout** to read data into strings
- using ==+== in between two strings concatenates the two strings to make a bigger one
- computer only reads into string vars until it encounters **whitespace**
- so you can't input strings that use spaces

	//how to fix this problem
	
	
**type compatibilities**
- as a rule, you cannot store a value of one type into a variable of another type
- not all compilers behave the same when this done (some give errors, some warnings, others - nothing)
- it is acceptable to assign a value of type ==int== to a ==double==, but not ==vice versa==
- although possible, it is a bad idea to store an ==int== value as a ==char== (C++ considers chars to be small integers on many occasions b/c ==char== vars consume less memory than ==ints== when doing arithmetic
- even if the compiler does not enforce type compatibility, it is a good idea to follow the rule
- ==booleans== can be assigned to integer typed vars
- when assigned to ==bool==, any nonzero integer is true; zero is false
- when assigned to ==int==, true is 1, false is 0

**arithmetic operators and expressions**
- two operands of ==ints== create ==ints==
- two operands of ==float== and ==int== create a ==float==
- integer division discards anything other than whole number results, and numbers are not rounded
- ==%== operator can be used with operands of type ==int== to recover the remainder
- ==/== and ==%== operators act diff. with neg. #s
- precendence rules are similar to algebra

##2.4 

**simple branching mechanism**
	
	if (boolean expression){
		//do;
	else{
		//do;
		}
	//comparison operators
	//equal: ==
	//not equal: !=
	//less than: <
	//less than or equal to: <=
	//greater than: >
	//greater than or equal to: >=
	
	//combine two operators using 'and' operator:
	//&&
	//or use the 'or' operator:
	//||
	//other operators:
	//'not' operator: !
	
**simple loop mechanisms**

	//while loop syntax:
	while(true boolean expression){
	//statement
	}
	
	//a do-while loop executed the body
	//of the loop at least one time 
	//regardless of the truth of the boolean
	//expression. The body of the loop is 
	//performed, after which the do-while 
	//loop behaves like a while loop.
	do{
		statement;
		}
	while (boolean expression);

**increment and decrement operators**
- ==++== is the increment operator
- ==- -== os the decrement operator
	 


	

	


	
	



	

